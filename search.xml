<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDBC学习笔记]]></title>
    <url>%2F2019%2F03%2F25%2FJDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JDBC基础知识什么是JDBC JDBC是一种用于执行SQL语句的Java API，它是由一组用Java语言编写的类和接口组成。它提供了一种操作数据库的标准。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统 JDBC的机制：通过驱动包连接数据库，使用JDBC的API操作驱动包从而操作具体数据库 JDBC里面包含了数据库操作的规范类，接口，方法，但是JDBC自己并没有具体实现这些规范。而是通过驱动包来实现。各大数据库厂商根据JDBC规范，自己去实现JDBC的API的具体细节，而这些实现的API称为驱动包，要连接那个数据库，就将该数据库的JDBC驱动包导入，然后通过JDBC的API去操控驱动包，从而去操控具体的特定的数据库。 JDBC的API是java.sql包，使用JDBC时，只需要导入这个包到程序里就行。 图示：![](http://ww1.sinaimg.cn/large/006dQ9gUgy1g1f6d4roo9j30fb0503yh.jpg) 连接MySQL 添加驱动：就是从Java程序连通到驱动包 **在项目中创建lib并将MySQL的驱动包复制进来 **builder path 编译路径 创建连接：就是从驱动包连接到数据库 A.加载驱动：把com.mysql.jdbc.Driver这份字节码加载进JVM，当该字节码加载进JVM时，就会执 行该字节码的静态代码块，该字节码的静态代码块会注册该驱动(看源码)​ Class.forName(“com.mysql.jdbc.Driver”); //com.mysql.jdbc.Driver是驱动的名称 B.获取连接对象：即连接上数据库 **获取连接对象需要数据库的地址URL，数据库的用户名和密码,url的格式是jdbc:mysql://主机名:端口/数据库名** String url=&quot;jdbc:mysql://localhost:3306/mytest&quot;; String user=&quot;root&quot;; String password=&quot;1234&quot;; Connection c=DriverManager.getConnection(url,user,password); 用Java程序操作MySQL创建表 A.加载驱动：Class.forName(“com.mysql.jdbc.Driver”); B.连接到数据库：Connection conn=DriverManager.getConnection(url,user,password); C.创建要执行的SQL语句 使用连接对象获取Statement对象，Statement接口是用来执行静态的SQL语句的。 用Statement对象把SQL语句对象发送到数据库中执行，并返回执行结果：对于DQL语句返回查询结果集，对于DML语句返回受影响的行数，对于DDL返回0。例： String sql=&quot;create table stu(id int,name varchar(25),age int)&quot;; Statement st=conn.createStatement(); D.执行SQL语句 DDL语句,DML语句使用Statement对象的：int execuUpdate(String sql) 方法 DQL语句使用Statement对象的：ResultSet executeQuery(String sql) 例： int row=st.executeUpdate(sql); E.释放数据资源 为什么要释放资源？ 其实Connection连接就相当于Java到MySQL之间建立了管道，而Statement就是连接到MySQL的 执行引擎来执行sql语句。 **要关闭那些资源？** res.close(); //先关闭结果集，如果有的话 st.close(); //再关闭的是数据库到mysql.exe的管道 conn.close(); //最后关闭的是Java程序到Mysql服务器的管道 异常处理 12345678910111213141516try &#123; Class.forName("com.mysql.jdbc.Driver"); conn=DriverManager.getConnection(url,user,password); //执行DML语句 String sql="insert into stu values(2,'李四',20)"; st=conn.createStatement(); int row=st.executeUpdate(sql); System.out.print(row); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if(st!=null) &#123;try &#123; st.close(); &#125; catch (SQLException e) &#123;e.printStackTrace();&#125;&#125; if(conn!=null) &#123;try &#123; conn.close(); &#125; catch (SQLException e) &#123;e.printStackTrace();&#125;&#125; &#125; JDBC执行SQL语句 执行DDL语句,DML语句:使用Statement对象的：int execuUpdate(String sql) 方法该方法执行DML返回受影响的行数，执行DDL返回0； 执行DQL语句:使用Statement对象的：ResultSet executeQuery(String sql) 方法,该方法会返回结果集对象。 JDBC的结果集ResultSet类对象：代表从数据库查询的结果，该类的方法： boolean next() :判断是否有下一行数据，若有则自动移动到下一行，用于遍历结果集 getXxxx(Sting 列名)：获取当前行的 指定列名 的数据，其中Xxxx代表该列的数据类型 getXxxx(int 列号)：获取当前行的第几列(从1开始)的数据，其中Xxxx代表该列的数据类型当该列数据类型是 varchar/char/text类型时，Xxx代表String，当该列的类型是int/integer时，Xxx代表Int。 例： 123456789String sql="select * from emp";ResultSet res=st.executeQuery(sql);while(res.next())&#123; int empno=res.getInt("empno"); String ename=res.getString("ename"); String job=res.getString("job"); System.out.println("empno = "+empno+" ename = "+ename+" job = "+job);&#125; DAO(Data Access Object,数据存取对象)设计结束 没有使用DAO存在的问题：当一个程序要去数据库例里查询数据，必须都得自己去加载驱动，连接对象，创建语句,执行语句，释放资源这五个步骤，每个Java程序都这样做，重复代码太多。 什么是DAODAO是位于业务逻辑层(java程序)和持久层(数据库)之间的一个抽像层，它是实现对持久层数据的访问。业务逻辑层只需要告诉DAO要对数据做什么，由DAO层来进行具体操作。DAO层自己实现加载驱动，连接对象，创建语句，执行语句，释放资源。然后向业务逻辑层提供增删改查的操作接口和方法，业务逻辑层只需要简单的调用方法即可访问数据库。大大简化了程序编写。降低耦合。ORM(Object Relation Mapping,对象关系映射)介绍 什么是ORMORM是一种模型，是一种程序设计技术思想，它将关系数据库中的表的记录映射成对象，将表中每一条记录都变成一个对象，目的是方便开发人员以面向对象的思想来实现对数据库的操作。 表和对象的对应关系 类 表 对象 记录(行) 属性 字段(列) 例： 一个表为：Person(name varchar(25),age int,gender varchar(5)) 则表对应的类为： class person{ //类名跟表名一样 String name; //属性名和属性类型跟表的字段名和字段属性都得一样。 int age; String gender; } 表中一条记录对应为一个对象：Person p=new Person(); domain介绍 什么是domaindomain就是一个类，人们习惯成为这个名字，该类符合JavaBean的规范。它的作用是作为Java程序和数据库的核心中转站。这个类一般是 ORM 中的类,它其实就是表对应的类,它将数据库中数据，进行封装，并提供get/set供DAO和Java程序进行获取和设置数据。简单说：domain就是将记录中的列设计成属性，并给每个属性设计get/set方法。 面向接口编程 为什么要定义接口 根据客户需求先定义接口,业务具体实现通过实现类来完成,当客户提出新需求,只需要编写该业务逻辑的新实现类即可。 例： 假设客户要求写一个数据库DAO组件，先定义好接口(,连接接口，增删改查方法接口等)，突然根据需要，程序要 连接Oracle数据库，而之前只写MySQL数据库，这时只需要多写一个继承同一套接口的实现类即可。 面向接口编程的好处 **业务逻辑更加清晰 **增强代码的扩展性 **接口与实现相分离，适合团队协作。例如负责界面和后台开发，后台提供一套接口给界面人员使用，具体实现 后台去做，界面只管用即可。这样界面开发人员就不用等后台人员写好实现类再去开发界面了。 **降低耦合度，便于以后升级扩展 DAO组件开发：基于上面三个概念DAO，ORM，domain来设计DAO组件。 思想：先根据ORM模型写好domain类，再写好DAO组件 DAO设计规范 定义DAO接口 编写对应DAO接口的实现类 包名规范：包名使用：域名倒写.模块名.组件名DAO包规范： edu.scnu.jdbc.domian //该包存储所有domian类 edu.scnu.jdbc.dao //该包存储所有dao接口 edu.scnu.jdbc.dao.impl //该包存储所有dao接口的实现类 edu.scnu.jdbc.dao.test //该包存储所有DAO组件的测试类 类名规范 domain类：类名跟表名一样，且见名知。存储在domain包中，用于描述一个对象，是一个JavaBean。 dao接口：I+domain类名+Dao，如：IStudentsDao。存储在dao包中，用于表示某一对象的CRUD声明。 dao实现类：domain类名+Dao+Impl，如：StudentsDaoImpl。存储在dao.impl包中，表示实现DAO接口的实现类 开发步骤 (1).创建表 (2).建立domain包和根据ORM模型编写domain类 (3).建立dao包和根据面向接口编程思想编写dao接口 (4).建立dao.impl包和dao实现类 (5).根据dao接口创建dao测试类 (6).编写实现类当中dao声明的方法体 (7).每编写一个dao方法，进行单元测试，测试功能是否正确 先写好上面的代码，再重构，这些代码，提高精简性，扩展性。 重构代码原则： 同一个类中：在一个类里有多个方法中有较多重复代码时，就把它们抽到一个方法里，这些代码不同的地方通过参数传递进去。 不同类中：不同类中有较多共同代码时，就抽取到一个新类里，大家再共享该类的内容。 抽取DML语句方法： 设计一个方法，要求传入两个参数，一个是预编译的sql语句，一个是预编译语句的参数，该参数为可变参数。返回受影响行数 12int execuUpdate(String sql,Object...params)&#123;.....&#125;this.execuUpdate(&quot;select * from stu where id=? and name=?&quot;,13,&quot;张三&quot;); 抽取DQL语句方法：跟DML类似，不过是返回类型和里面的逻辑有差异而已。 抽取DQL语句时对结果集的处理 还会用到内省进制：内省就是用于查看和操作JavaBean中的属性。即方便获取JavaBean类的get/set方法。 怎么使用内省 使用Java API的几个个类：Introspector类 BeanInfo类 步骤： A.使用Introspector类的一个静态方法 BeanInfo getBeanInfo(Class A,Class B) 获取一个JavaBean类的信息.其中A代表要获取的该类和其父类的信息，B表示如果它是A的父类，就忽略这个父类的信息。 B.用得到的BeanInfo对象的方法PropertyDescriptor[] getPropertyDescriptors()获取该类的所有属性的属性描述器. C.遍历得到的属性描述器数组，并使用属性描述器对象的方法获取该属性的信息; String getName() //获取该属性的属性名 Method getReadMethod() //获取该属性的get方法 Method getWriteMethod() //获取该属性的set方法 D.在使用该javaBean类的字节码创建一个该类的对象：类名 obj=类名.class.newInstance(); E.再用获取到的Method对象和用字节码创建的对象，使用该对象调用该Method代表的方法：Method对象名.invoke(用字节码创建的对象,该方法的实参列) 例: 1234BeanInfo bean=Introspector.getBeanInfo(User.class,Object.class);PropertyDescriptor[] pds=bean.getPropertyDescriptors();User u=User.class.newInstance();pds[0].getReadMethod().invoke(u,"zhangsan"); 3.Statement接口： (1).用于进行Java程序和数据库之间的数据传输。即负责把SQL语句发给数据库的执行程序mysql.exe执行，并获取结果 (2).该接口有三个具体的子类： Statement：用于对数据库进行通用访问，使用的是静态sql PreparedStatement：用于预编译sql模板语句，在运行是接受sql语句参数构成完整的sql语句。 CallableStatement：使用JDBC调用存储过程。 (3).Statement类执行静态sql语句 先拼接好sql语句 获取Statement对象，使用连接对象的createConnection()方法 用Statement对象将语句发送给数据库 例1：执行DML语句 String sql = &quot;insert into student(name,age) values(&apos;&quot; +stu.getName + &quot;&apos;,&quot; + stu.getAge +&quot;)&quot;; Stetament st=conn.createStatement(); st.execuUpdate(sql); //记住要传参 例2：执行DQL预编译语句 Stetament st = conn.createStatement(); String sql = &quot;select * from student&quot;; ResultSet res = st.executeQuery(sql); (4).使用PreparedStatement类执行预编译语句 没有预编译语句时，所有sql语句都是静态的，即sql都要拼接，且执行前就要确定。 有预编译语句，在性能和代码灵活性上有显著提高 预编译语句更安全，如防止sql注入(就是通过把SQL语句插入到 web表单提交或输入域名或页面请求得查询字符串，最终达到欺骗服务器执行恶意的SQL语句，原理是：使用单引号截断静态sql语句，从而改变语义)。使用预编译语句会将传入的单引号转义，变成 \’ ，这样就无法截断sql语句，进而无法拼接sql语句，从而防止sql注入。 JDBC执行SQL语句的机制：Java程序通过DriverManager对象注册Connection对象，从而使Java程序连接上数据库系统，之后用连接对象创建Statement对象将sql语句发送给数据库系统，数据库系统拿到sql语句，先进行安全性分析和语法分析(因为DBMS获取的使字符串，要转为sql语句)，然后到预编译语句池里查找该sql语句是否已经存在了，若是，直接执行。若没有就进行编译并保留在预编译池，再给mysql.exe执行。而如果使用预编译语句，PreparedStatement会把该预编译语句和参数一起发送给DBMS，预编译池编译第一次该预编译语句，然后将传来的参数填上，之后再发送该预编译语句，就直接拿存在预编译池的加上新参数即可。而静态sql语句，由于每一次参数不一样，因此每次都得编译。（mysql没有预编译池，故性能上体会不高）。 预编译语句书写：先写好预编译模板SQL语句，其中的参数使用 ？作为占位符，表名该位置可以传参。然后使用setXxx(index,value)方法将实参输入第index位置的占位符中，index从 1 开始。Xxx根据value的类型而定，如value是varchar，Xxx为String。然后使用PreparedStatement对象进行封装，之后使用PreparedStatement类的方法，根据sql语句调用对应方法。 例1：执行DML预编译语句 String sql=&quot;select * from student where id=? and name=?&quot;; PerparedStatement ps=conn.prepareStatement(sql); ps.setInt(1,10); ps.setString(2,&quot;张三&quot;); ResultSet res=ps.execuQuery(); //记住execuQuery()跟执行静态sql语句不一样，它不需要参数。 例2：执行DQL预编译语句 String sql=&quot;insert into student values(?,?)&quot;; ps.setInt(1,10); ps.setString(2,&quot;张三&quot;); PerparedStatement ps=conn.prepareStatement(sql); ps.execuUpdate(); (5).CallableStatement类：使用JDBC调用存储过程。 步骤： 在数据库当中定义一个存储过程 使用连接对象的方法prepareCall(String sql)获取CallableStatement对象,这里的sql语句也可以使用预编译 使用得到的CallableStatement对象设置参数 使用得到的CallableStatement对象的方法executeQuery()方法执行调用存储过程的sql语句，返回一个结果集对象 从结果集对象获取数据注：这里调用存储过程的sql语句有点不一样，调用存储过程格式：{ call 存储过程名(占位符) }对占位符赋值也有所不同，对于in型参数，使用setXxx(Xxx)方法，而对out型参数，则得这样： 使用CallableStatement对象的registerOutParameter(index,out型参数的sql类型)， 例1：JDBC调用一个参数的存储过程 Connection conn = JDBCUtil.getConn(); CallableStatement prepareCall = conn.prepareCall(&quot; { call getStu(?) } &quot;); //sql语句有点特殊 prepareCall.setString(1, &quot;王五&quot;); ResultSet res = prepareCall.executeQuery(); if(res.next()) { Student stu=new Student(); stu.setId(res.getInt(&quot;id&quot;)); stu.setName(res.getString(&quot;name&quot;)); stu.setAge(res.getInt(&quot;age&quot;)); System.out.println(stu); } 例2：JDBC调用含输入输出参数的存储过程 Connection conn = JDBCUtil.getConn(); CallableStatement prepareCall = conn.prepareCall(&quot;{call getName(?,?)}&quot;); prepareCall.setInt(1, 6); prepareCall.registerOutParameter(2,Types.VARCHAR); //不一样的地方 prepareCall.execute(); //不一样的地方 String name=prepareCall.getString(2); System.out.println(name); 4.JDBC处理事务：在Java程序中有些操作要当成一个事务来执行才不会出错。 默认情况下，事务是自动提交的，因此为了执行自己写事务，要先设置为手动提交。 MySQL的InnoDB才支持外键和事务，MyISAM不支持外键和事务在写Java代码(或写SQL)时，只要进行 增，删，改才需要设置事务，查询不必设置事务 JDBC处理事务过程 关闭事务自动提交：使用连接对象关闭：conn.setAutoCommit(false);写上必须当作一个事务来执行的Java代码片段 该Java代码片段没有异常时，使用连接对象提交事务：conn.commit() 该Java代码片段有异常时，使用连接对象进行回滚：conn.rollback()。回滚之后，事务结束，释放资源。事务的回滚是写在异常处理里面的，当该Java代码片段异常时，若不进行回滚，虽然不会更新数据库，但会占用资源所有出现异常时，要进行回滚。例： try { //开启事务手动提交 conn.setAutoCommit(false); //zs账号减少1000 sql=&quot;update account set money = money-? where name=?&quot;; ps=conn.prepareStatement(sql); ps.setDouble(1, 1000); ps.setString(2, &quot;zs&quot;); ps.executeUpdate(); 3/0; //这里出现异常，但由于没有执行到 conn.commit(); ，即事务没提交,之前的数据库操作 //并没有执行，因此解决了zs账号少钱了，ls却没增加的情况。 //ls账号加1000 sql=&quot;update account set money = money+? where name=?&quot;; ps=conn.prepareStatement(sql); ps.setDouble(1, 1000); ps.setString(2, &quot;ls&quot;); ps.executeUpdate(); //提交事务 conn.commit(); //只要事务提交，数据库才执行Java的Statement接口发送过来的sql语句。否则就是Java代码执行了 //只要出现异常，没执行到这行代码，对数据库进行的操作就没用。 }catch(Exception e){ conn.rollback(); //若不回滚事务，会占用着资源。 } 5.批处理： (1).什么是批处理：一次性执行多条sql语句，允许多条语句一次性提交给数据库批量处理，比单独提交处理效率更高。 (2).怎么使用批处理： A.将需要批处理的sql语句添加在一起：使用Statement接口的方法：addBatch(String sql) B.：使用Statement接口的方法将批处理提交执行：executeBatch() 例： Connection conn = JDBCUtil.getConn(); String sql=&quot;insert into student (name,age) values (?,?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); for(int i=0;i&lt;1000;i++) { ps.setString(1,&quot;zhangsan&quot;+i); ps.setInt(2, 18); //如果不用批处理，每循环一次就发送一条sql语句给数据库执行，效率低 //ps.executeUpdate(); //使用批处理，先加到批处理里，再在循环外一次性提交 ps.addBatch(); } ps.executeBatch(); (3).注意事项：默认情况下，MySQL是不支持批处理的，从5.1开始，可以在数据库的url里添加一个参数：rewriteBatchedStatements=true来开启批处理。 例： 1String url = "jdbc:mysql://localhost:3306/数据库名?rewriteBatchedStatements=true"; 6.池 (1).没有连接池的情况 每次CRUD操作要使用数据库时，都要创建一个新的连接对象。普通的JDBC数据库连接使用DriverManager来获取而DriverManager每次都要将Connection加载到内存中，并且验证数据库的用户名和密码，而每次CRUD操作执行时，都获得一个连接对象，执行完后又释放断开连接，这样会大大消耗资源和时间。连接对象资源没得到很好的重复利用。 (2).池的介绍 什么是池：池就是保存对象的容器，保存的对象叫什么该池就叫什么池 连接池就是保存数据库连接对象的容器 连接池的作用：系统启动初始化时，先创建一定数量的对象，需要时直接从池中取出一个空闲对象(没有就等待或新建)，用完后并不直接销毁，而是放回对象池中以便重复利用。 池的优势就是可以消除对象创建的所带来的延迟，从而提高系统性能。并且可以设置池的大小，控制访问量，还可以通过池的管理机制监视系统的访问数量，使用情况，为系统开发，测试及性能调整提供依据。 (3).池的属性：合理设置池的属性，会提高池的性能 初始化连接数：初始化时，池中创建的对象数 最大连接数：池中最多存储的对象数 最小连接数：池中最少存储的对象数 最大空闲时间：应用获取一个池中的对象后，在指定时间内没有任何动作，就会自动释放该对象 最大等待时间：在指定时间内，一直尝试获取池中对象，超出该时间，就会提示获取失败。 7.连接池的使用 (1).在Java中提供了一个javax.sql.DataSource接口来表示连接池，DataSource跟JDBC一样，是一个规范，只提供一个接口，具体实现由第三方根据需要实现，只需遵循规范即可。 常见的连接池实现 DBCP：Spring推荐，Tomcat的数据源就是使用DBCP C3P0：它是一个开源代码的JDBC连接池，它和Hibernate一起发表，2007年后就不更新了，性能较差 Druid：阿里巴巴提供的连接池，除了连接池的功能外，还有更多的功能。国内常用 DataSource(数据源)和连接池Connection Pool是同一个东西，只是叫法不一样而已。 使用连接池与不使用连接池的区别： 获取连接对象方式不同： 传统：Connection conn=DriverManager.getConnection(url,user,pwd); 连接池：先用第三方的包获取数据源DataSource对象，在用DataSource对象获取池中的对象：Connection conn=DataSource对象.getConnection(); 释放资源方式不同： 传统：直接和数据库断开连接，销毁连接对象。使用连接对象的close()方法。 连接池：把连接对象还给连接池，下一个用户还可以继续使用 (2).连接池的操作 主要学习如何创建DataSource对象，再从DataSource对象中获取Connection对象获取连接对象后，其余CRUD等操作跟以前一样(获取Statement对象/PreparedStatement对象，执行SQL语句等)，不同的数据库连接池，在创建DataSource上不一样这些都是第三方提供好的，直接使用即可。 (3)DBCP连接池的使用： 获取DataSource对象：(即创建连接池并设置该池的参数，如最大连接数) 123456789101112//url的格式是jdbc:mysql://主机名:端口/数据库名String url="jdbc:mysql://localhost:3306/my_test"; String user="root";String password="1234";String driverName="com.mysql.jdbc.Driver";//创建连接池BasicDataSource ds=new BasicDataSource();//初始化池ds.setDriverClassName(driverName);ds.setUsername(user);ds.setPassword(password);ds.setUrl(url); 获取池中的连接对象 123456Connection conn=ds.getConnection(); //之后的操作跟之前一样String sql="select * from student where name='李四'";Statement st = conn.createStatement();ResultSet res = st.executeQuery(sql);conn.close(); //这时并没有销毁该对象，只是还回池中而已。 使用配置文件对连接池进行设置 配置文件：是一种资源文件，以.properties为扩展名。配置信息以 键=值 形式存在。在上面使用数据库过程中，我们把数据库的连接地址，用户名，密码都写在代码里，不便于后期维护。因为我们的项目是部署到别人服务器里，别人的数据库连接信息肯定不一样，那部署人员部署项目时要连接数据库只能去该你写的Java代码，到他们不一定知道你怎么写的，因此为了安全和便利，专门提供一个配置文件，部署人员只需在配置文件上改就可以了。 读取配置文件（先创建一个 source folder文件夹，然后创建一个.properties文件并输入信息） 12345678//创建配置文件对象Properties p=new Properties();//读取文件InputStream in=new FileInputStream("src/db.properties");//加载配置文件p.load(in);//根据键名获取配置信息p.getProperty("键名"); 连接池读取配置文件来设置数据源(连接池) 例： 123456Properties properties=new Properties();InputStream in = new FileInputStream("resource/db.properties");properties.load(in);DataSource ds=null;//直接将配置文件给数据源即可,它会自动读取并设置ds=BasicDataSourceFactory.createDataSource(properties); **注：使用DBCP来加载配置文件，配置文件的键名就有了规定，要按要求。不按要求会出错.** (4).Druid(德鲁伊)连接池的使用 Druid是一个JDBC组件库，不仅包含数据库连接池，还有SQLParser等组件。DruidDataSource是最好的数据库连接池，DruidDataSource的配置是兼容DBCP的，因此从DBCP迁移到DruidDataSource，只需需改数据库实现类即可。只需要将DBCP的代码中的 BasicDataSourceFactory 改为 DruidDataSourceFactory 即可。这样就迁移了。 DruidDataSource的使用 例： 12345Properties properties=new Properties();InputStream in = new FileInputStream("resource/db.properties");properties.load(in); //直接将配置文件传给数据源就可以，它会自动读取并设置//DBCP和Druid就这句不一样而已DataSource ds=DruidDataSourceFactory.createDataSource(properties); 三.其他1.存储图片 (1).数据库中可以直接存储图片的，将图片转为二进制即可。使用数据库中的数据类型：BLOB类型。它将图片，音频，视频转为二进制流之后就可以直接存储到数据库里了。 BLOB类型： TINYBLOB：255字节 BLOB：65535zijie MEDIUMBLOB：16M LONGBLOB：4G实际上，真正的开发中，不会直接将多媒体存放到数据库里的，而是把多媒体文件的路径保存到数据库里，以后再取出该路径，根据该路径到那里拿。 (2).存储图片的操作 在表里添加一个字段，该字段类型为BOLB类型 通过Java代码存入一张图片：setBlob(index,InputStream) 从数据库里取出图片： InputStream in = res.getBlob(“image”).getBinaryStream();例1：存入一张图片到数据库 12345Connection conn = JDBCUtil.getConn();String sql="insert into media (image) values (?)";PreparedStatement ps = conn.prepareStatement(sql);ps.setBlob(1,new FileInputStream("d://1.jpg")); //直接将图片路径 ps.execuUpdate(); 例2：从数据库里取出图片 1234567891011String sql="select * from media where name=?";PreparedStatement ps = conn.prepareStatement(sql);ps.setString(1, "美女");ResultSet res=ps.executeQuery();if(res.next()) &#123; //获取图片 Blob blob=res.getBlob("image"); //获取图片的二进制流 InputStream input=blob.getBinaryStream(); Files.copy(input, Paths.get("d:/美女复件")); //将文件复制一份&#125; 2.获取自动生成主键在我们设置表时，会设置主键并设置自动增长，但我们用JDBC插入数据时，要想知道我们生成的主键是多少。需求场景：用户注册时，添加用户名，密码后，点击注册，这时服务器后台将注册信息插入数据库，并跳转到完善个人信息的页面，用户填完这个后，提交到服务器里，这时服务器后台要将这些数据更新到刚刚插入的那条记录里，因此要获取刚刚插入的那条记录的主键，再根据主键更新数据。 (1).获取方法 设置可以获取主键​静态语句： 1234567891011Connection conn = JDBCUtil.getConn();String sql="insert into student (name,age) values ('zs',29)";Statement st = conn.createStatement();//设置可以获取主键st.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);//获取主键ResultSet res=st.getGeneratedKeys();if(res.next()) &#123; int id=res.getInt(1); System.out.println(id);&#125; 预编译语句： 12345678910111213Connection conn = JDBCUtil.getConn();String sql="insert into student (name,age) values (?,?)";//预编译语句设置可以获取主键PreparedStatement ps = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);ps.setString(1, "lisi");ps.setInt(2, 99);ps.executeUpdate();//获取主键ResultSet res=st.getGeneratedKeys();if(res.next()) &#123; int id=res.getInt(1); System.out.println(id);&#125; 获取主键无论是静态sql语句，还是预编译语句。都使用Statement对象的方法：ResultSet getGenerateKeys()​例： 123ResultSet res=st.getGenerateKeys();if(res.next())int id=res.getInt(1); 3.DBUtils的使用：DBUtils是一个Apache开发的一个框架，它封装JDBC的一些常用操作，可以很方便的操作数据库 使用步骤： (1).获取QueryRunner对象,传一个数据源给该对象，它会自动从连接池里获取对象，并提供一些简便操作 1QueryRunner qr=new QueryRunner(DataSource ds); (2).写好预编译语句或静态语句。 1String sql="select * from stu where id=?"; (3).使用QueryRunner对象执行sql语句 DML/DDL语句：update(String sql,Object…params)​例： 1qr.update(sql,&quot;张三&quot;,18,&quot;男&quot;); DQL语句：query(String sql,ResultSetHandler rs,Object…params),其中ResultSetHandler是结果集处理器，ResultSetHandler类根据内省来从结果集里取出值封装到对象里。ResultSetHandler类有BeanHandler(Class c)，BeanListHandler(Class c),MapListHandler(Class c)，等子类。例： 123qr.query(sql, new BeanHandler&lt;person&gt;(person.class), "张三",18,"男");//将查询结果封装成一个指定对象的列表qr.query(sql, new BeanListHandler&lt;person&gt;(person.class), 4);]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2019%2F03%2F23%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[linux的介绍Linux的文件目录结构0.Linux中一切皆文件1.Linux目录和Windows目录有着很大的不同，Linux目录类似一个树，最顶层是其根目录（没有什么c盘，d盘）2.根目录下面有几个常用目录 /bin 二进制可执行命令 /dev 设备特殊文件 /etc 系统管理和配置文件 /etc/rc.d 启动的配置文件和脚本 home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 /lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件 /sbin 超级管理命令，这里存放的是系统管理员使用的管理程序 /tmp 公共的临时文件存储点 /root 系统管理员的主目录 /mnt 系统提供这个目录是让用户临时挂载其他的文件系统 /lost+found这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里 /proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 /var 某些大文件的溢出区，比方说各种服务的日志文件 /usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录，其中包含：/usr/x11R6 存放x window的目录 /usr/bin 众多的应用程序 /usr/sbin 超级用户的一些管理程序 /usr/doc linux文档 /usr/include linux下开发和编译应用程序所需要的头文件 /usr/lib 常用的动态链接库和软件包的配置文件 /usr/man 帮助文档 /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里 /usr/local/bin 本地增加的命令 /usr/local/lib 本地增加的库根文件系统 3.Linux的一些内容意思 当显示一个目录的内容时，会显示以下形式，其中每个字段意思不一样 drwxr-xr-x. 2 root root 6 8月 1 19:39 a -rw——-. 1 root root 1274 7月 30 00:09 anaconda-ks.cfg -rw-r–r–. 1 root root 186 8月 1 16:22 a.txt 第一位表示文件类型：d表示文件，-表示目录，|表示链接文件 第二位表示当前用户是否可读：r代表可读， 第三位表示当前用户是否可写：w代表写，-代表不行 第四位表示当前用户是否可执行它：x可以，-不行 5-7位代表当前用户所在的组的其他用户对该文件的权限 8-10位代表其他非本组用户： 第一个root表示组 第二个root表示用户 之后依次是文件大小（kB），时间，文件名 目录文件操作 注：通过上下键可以将上面/下面的命令复制到当前输入行，在输入命令时，如果太长，按一下 tab 键，会自动补齐：使用：clear //清空当前屏幕 1.pwd：print working directory缩写，显示当前工作的目录名 2.cd：change directory缩写，切换目录 格式： cd [/根目录下的子目录] //进入该目录 常用例子： cd ~ //波浪线 ~ 表示当前用户的目录，例如用户是root，就进入root，用户是张三，就是张三的 cd / //根目录 cd - //减号，上一次访问的目录 cd .. //上一级目录 cd //缺省，进入当前用户目录 3.ls：list的缩写，列出当前进入的目录内容 格式：ls [参数1][参数2] [/文件或目录] 参数有： -a或–all 列出所有文件和目录，包括隐藏文件，特殊目录 -l 使用详细格式列表列出 -t 用文件和目录的更改时间排序（正序） -r 指定反向排序，配合-t使用 –help 在线帮助 常用：ls -l //因为太常用了，可以简化为：ll 例子：ls -altr //以详细格式列出全部内容，并反向排序 ll ./b //显示当前目录下的 b 目录下的内容 4.mkdir：make directory缩写，创建目录 格式：mkdir [参数] 新目录名 参数有： -p：parent缩写，如果父目录不存在先生成父目录 -v：显示命令执行过程的详细信息 例子： (1).mkdir newfile //如果不指定路径，就在当前工作目录下创建新目录 newfile (2).mkdir /root/src/mylib //绝对路径,其中 root 和 root/src 必须存在，否则出错 (3).mkdir -pv a/b/c //在当前工作目录下先创建 a 目录，再在 a 目录下创建 b ，再在 b 目录下建 c 5.cp：copy缩写，复制文件或目录 格式：cp [参数] [源文件或目录] [目标文件或目录] 参数： -r或–recursive 递归处理，将指定目录下的文件和子目录一并处理 -b 如果要覆盖文件时，会将被覆盖文件进行配份 例： cp -r ./abc ./xxx //如果没参数r，就不能里面有子目录或文件 6.mv：move缩写，移动或 更名 现有的目录或文件 格式：mv [参数] [源文件或目录] [目标文件或目录] 参数： -f或–force： 强制覆盖不用询问，即当目的目录有重名文件，直接覆盖 例子： mv a.txt ./abc/a.txt mv ./a.txt ./b.txt //重命名7.rm：remove缩写，删除文件或目录 格式：rm [参数] [–help] [–version] [文件或目录] 参数： -f或–force: 强制删除，不用询问 -r或–recursive： 递归处理，将指定目录下的文件和子目录一并删除 例子： rm -f ./a.txt 8.find：查找文件或目录 格式：fine [目录] [参数] [查找范式即要查找的含有的字符串] 参数：-name：指定要查找的东西的名字，可使用正则 例子： find ./ -name ‘a*’ //在当前目录下查找名字开头有 a 的文件和目录9.touch：创建文件 例： touch ./ a.txt //在当前目录下创建a.txt 文档查看操作1.cat：catenate缩写，显示文本文件内容 格式：cat 文件名.后缀 //会将文本文件全部显示出来（没有分页），因此一般用于只有几行的文件2.more：分页显示文本文件内容，还支持直接跳转行功能 格式：more 文件名.后缀 执行这个命令后会显示第一页内容，之后按： Enter键 是向下n行，需要设置，默认是一行 空格键/Ctrl+F 是向下滚动一屏 B/Ctrl+B 返回上一屏 q 退出more，回到接收命令状态 3.less：分页显示文本文件内容，但操作更详细 格式：less [参数] 文件名.后缀 参数： -m 显示类似more命令的百分比 -N 大写N，显示每行的行号 执行这个命令后会显示第一页内容，之后按： Enter键 向下一行 Y 后退一行 空格键 是向下滚动一屏 B 返回上一屏 D 前进半页 U 后退半页 /+字符串 向下搜索 ?+字符串 向上搜索 v 进入vim编辑器 q 退出more，回到接收命令状态 5.tail：从文件尾开始显示 格式：tail [-行数] 文件名.后缀 其中行数是显示最后的几行 例子： tail -10 ./a.log //查看日志最后十行 6.grep：Global Regular Expression Print缩写，全局正则表达式版本，功能是用于过滤/搜索特定的字符，可用正则表达式来配合搜索 可以配合文本显示来使用，故称“管道” 格式1：grep [参数] pattern [文件路径] 格式2：其他命令 | grep [参数] pattern(过滤条件) //其他命令的输出是grep的输入，因此称为管道 参数有： -i或–ignore-case 表示忽略大小写 例子： grep -i mysql /root/install.log //表示搜索含mysql的内容 cat /root/install.log | grep -i mysql //与上述功能一样 ps -ef /root/ | grep -i install //将系统所有进程输出，并过滤不含install的进程去掉 文档编辑操作（vi/vim命令）1.基本操作 输入“vim 文件名”进入“一般模式” //相当于打开记事本了 按下“i”从一般模式进入“插入模式” //相当于用鼠标点一下文本框，接着可以输入了 按下“esc”从插入模式退出到“一般模式” 在“一般模式下”，输入“ :wq “,退编辑并保存 例子: vim ./a.txt —&gt;按 i —&gt;编辑—&gt;esc—&gt;:wq—&gt;完成 2.vi可以分为三种模式，分布是：一般模式(command mode)，插入模式(insert mode)，低行模式(last line mode) 一般模式(command mode)： 该模式下，可以控制屏幕光标的移动，对字符或行进行删除，移动和复制某区段以及进入插入/低行模式 插入模式(insert mode)： 只有该模式下，才可以编辑 低行模式(last line mode)： 该模式下，将文件保持或退出vi，也可以设置编辑环境或查找字符或列出行号等3.在输入 ”vim 文件名“ 后，按不同的键有不同的操作 （1）插入操作（从一般模式进入插入模式，即在一般模式下按一下键） i：在光标前插入 shift+i：在光标当前行开头开始插入，相当于Windows的”Home“键 a：在光标后插入 shift+a：在光标当前行末尾开始插入，相当于Windows的”End“键 o：在当前光标的下一行插入 shift+o：在当前光标的上一行插入 （2）复制或粘贴（在一般模式下的操作） yy：复制光标所在的整一行，类似于Windows的Shift+home或shift+end 数字+yy：复制光标所在之后的 n 行，n 由数字决定 p：粘贴在光标所在位置的新一行 （3）定位（在一般模式下的操作） gg：定位到文本第一行开头，类似于Windows的Ctrl+Home shift+g：定位到文本最后一行开头类似于Windows的Ctrl+End （4）删除（在一般模式下的操作） dd：删除光标所在行 数字+yy：删除光标所在之后的 n 行，n 由数字决定 （5）退出vim :q ：表示退出vi（没做修改时） :q! ：强制退出不保存 :w ：保存不退出 :wq ：保存后退出 系统命令1.ps：process Status缩写，显示系统所有进程信息的一个快照 格式：ps [参数] 参数有： -e：显示所有进程，类似于ls的-a -f：显示进程UID，PPIP，STIME栏位 例子： ps -ef2.kill：杀死进程命令， 格式：kill [参数] 进程ID 参数有： -9：强制退出 例子： kill -9 进程ID //可用通过ps命令查看进程ID3.ifconfig：显示网络链接信息，类似于Windows的ipconfig4.ping：测试网络是否联通 格式：ping IP号码 备份压缩/解压命令1.tar：功能是文件备份压缩/解压 格式：tar [参数] [操作后放的位置和新名] 要解压缩的(路径)文件名.后缀 参数有： -c：create缩写，建立一个压缩文件 -x：extract缩写，解压一个压缩文件 -z：是否使用gzip压缩 -v：verbose缩写，压缩的过程显示文件 -f：使新文档名，在f后面直接接文档名 解压组合：-zxvf //谐音记忆：注销vf 压缩组合：-zcvf //谐音记忆：注册vf 例子： tar -zcvf /root/b.tar /root/a //将a目录压缩到root下，并命名为b，因为用了-f参数 tar -zxvf ./b.tar //将b.tar解压到原目录 关机重启命令1.reboot：重启系统2.halt：立即关机 文件权限控制命令权限的一些概念：用户/组/权限 用户：Linux是一个多用户多任务的系统，root是最大权限的用户，其他用户是在home目录下保存 组：类似于数据库的角色机制，为一类相同权限的用户弄一个组 linux的用户分为四种类型：当前用户(2-4位)，当前用户所属的组(5-7位)，不是该组其他用户(8-10位)，所有用户(2-10位) 例： 输入 ls -l 命令显示的内容为：drwxr-xr-x. 2 root root 6 8月 1 19:39 a 1.chmod：change mode缩写，变更文件或目录的权限 格式：chmod [参数] [&lt;权限范围&gt;和&lt;符号&gt; 或 &lt;权限代号&gt;] 文件或目录名 参数有： -r或-recursive 递归处理，将指定目录下的文件和子目录一并处理 权限范围表示法： u：user即原来拥有该文件或目录的用户（一般是当前用户）(2-4位) g：group即原来拥有该文件或目录的所属组群(5-7位) o：other除了该文件或目录的拥有者和组外的其他所有用户(8-10位) a：all即所有用户(2-10位) 符号表示法： +：表示添加权限 -：表示取消权限 权限代号表示法： r：读取权限，数字代为 4 w：写权限,数字代为 2 x:执行或切换权限，数字代为 1 -：不具有任何权限，数字代为 0 例子： chmod u-rwx ./a.txt //给取消当前用户对a.txt的读写执行权限 chmod 157 ./a.txt //给当前用户对a.txt的执行权限(数字1)，改组其他用户读/执行权限(数字5=4+1)，其他用户全部权限 命令总结和帮助1.Linux命令分为两种：内部命令和外部命令 内部命令：属于Shell解析器的一部分，属于系统自带的 如：cd,pwd,help 外部命令：安装外部软件时，使用外部软件的命令。或者独立于Shell解析器的文件程序命令 如：ls，mkdir，cp 2.内部命令查看帮助文档：help+命令，如：help cd3.外命令查看帮助文档：man+命令，如：man ls4.一般先用 man 来查，没有再用 help 安装依赖包：其他软件所必须的运行环境(以centos为例，Ubuntu的把yum改为apt即可) 1.JDK依赖包: 命令：yum install glibc.i686 2.MYSQL依赖包: 命令：yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6 命令：yum update libstdc++-4.4.7-4.el6.x86_64 命令：yum -y install libncurses.so.5 libtinfo.so.5 3.redis依赖程序 命令：yum install gcc-c++ 查看安装的软件和卸载软件1.rpm -qa //查看所有安装的软件，加上管道可以查特定的软件，如：rpm -qa | grep java 查看是否安装了jdk2.卸载删除软件 rpm -e –nodeps 软件详细名 //一般通过 rpm -qa 先看一下名字 例： rpm -e –nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686 //卸载jdk1.6 安装外部软件（如：tomcat，mysql，Redis）1.先装好依赖2.在/usr/local/src/目录下创建安装目录，可使用mkdir（usr是Linux安装程序的默认目录，相当于Windows的programfile3.将安装包使用FileZill软件上传到linux中创建的目录（FileZill软件连接Linux的端口是 22）4.进入创建的目录，使用例：cd /usr/local/src/java5.若安装包是压缩文件，使用：tar -zxvf 安装包名 ，来解压一下就是安装了，之后可以重命名一下6.配置环境变量（如果需要的话），使用命令： （1）vim/etc/profile，然后将配置信息在该文件末尾添上 jdk配置信息： #set java environment JAVA_HOME=/usr/local/src/java/jdk1.7.0_71 CLASSPATH=.:$JAVA_HOME/lib.tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH （2）保存退出 （3）运行命令：source /etc/profile ，使配置信息生效 （4）输入java或rpm -qa查看是否成功 例子：1.安装Tomcat 1、创建web目录：mkdir /usr/local/src/tomcat 2、(虚拟机系统才需要)上传apache-tomcat-7.0.57.tar.gz 3、解压：tar -zxvf apache-tomcat-7.0.57.tar.gz 4、重命名：mv apache-tomcat-7.0.57 tomcat 5、启动tomcat：命令如下 cd itcast-usermanage/bin/ ./startup.sh 或者 sh startup.sh 6、查看日志：tail -f ../logs/catalina.out 7、查看启动效果： http://192.168.0.160:8080/ ，结果发现访问不了，这可能是因为Linux没有开 放8080端口，可以通过命令：/etc/init.d/iptables status 查看开发了那些端口 8、打开 8080 端口，命令如下： /sbin/iptables -I INPUT -p tcp –dp ort 8080 -j ACCEPT //打开8080端口 /etc/rc.d/init.d/iptables save //保存，是开放生效 例子：2.安装mysql 1、mkdir /usr/local/src/mysql 2、cd /usr/local/src/mysql 3、tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar 4、安装server：rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm //有可能出错，没依赖，安装：yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6 5、安装client：rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm //有可能出错，没依赖，安装：yum -y install libncurses.so.5 libtinfo.so.5 6、查询mysq服务运行状态，执行命令：service mysql status 查看是否启动了mysql 7、如果服务未启动。启动mysql服务：service mysql star]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议总结]]></title>
    <url>%2F2019%2F03%2F11%2FTCP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[TCP协议是什么TCP协议是提供一种面向连接的、可靠的字节流服务的传输层协议。 什么是面向连接，怎么达到面向连接面向连接就是在通信时，必须先进行连接，建立起一对一的通道。 通过三次握手，四次挥手达到面向连接 什么是可靠的字节流服务，怎么达到可靠性可靠性就是，确保对方无论如何都能够收到全部数据，且数据是正确的。两个应用程序通过 TCP连接交换8 bit的字节构成的字节流。 TCP不在字节流中插入记录标识符，这称为字节流服务( byte stream service)。 通过确认机制和超时重传(让双方知道数据被收到了)，序列号标记(保证数据的顺序和全面)，滑动窗口(控制数据的传输大小)。TCP通过下列方式来提供可靠性: 应用数据被分割成 TCP认为最适合发送的数据块。这和 UDP 完全不同，UDP 应用程序产生的数据报长度将保持不变。由 TCP 传递给 IP 的信息单位称为报文段或段( segment)。我们将看到 TCP 如何确定报文段的长度。 当 TCP 发出一个段后,它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认,将重发这个报文段。我们将了解 TCP 协议中自适应的超时及重传策略。 当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送,通常将推迟几分之一秒，这将在 下面讨论。 TCP 将保持它首部和数据的检验和。这是一个端到端的检验和,目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错, TCP 将丢弃这个报文段和不确认收到此报文段(希望发端超时并重发)。 既然TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。如果必要，TCP 将对收到的数据进行重新排序,将收到的数据以正确的顺序交给应用层。 既然 IP 数据报会发生重复，TCP 的接收端必须丢弃重复的数据。 TCP 还能提供流量控制。TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建个人博客]]></title>
    <url>%2F2019%2F02%2F28%2F%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[开始搭建：https://blog.csdn.net/pan861190079/article/details/80860153更换主题和基本配置：http://theme-next.iissnan.com/getting-started.html个性化配置：http://shenzekun.cn/hexo的next主题个性化配置教程.html]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
